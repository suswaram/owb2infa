package org.willian.owb2infa.helper.infa;

import java.io.File;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.LineNumberReader;
import java.util.Properties;
import org.apache.log4j.LogManager;
import org.apache.log4j.Logger;
import com.informatica.powercenter.sdk.mapfwk.connection.ConnectionInfo;
import com.informatica.powercenter.sdk.mapfwk.connection.ConnectionPropsConstants;
import com.informatica.powercenter.sdk.mapfwk.connection.SourceTargetType;
import com.informatica.powercenter.sdk.mapfwk.core.Folder;
import com.informatica.powercenter.sdk.mapfwk.core.MapFwkOutputContext;
import com.informatica.powercenter.sdk.mapfwk.core.Mapping;
import com.informatica.powercenter.sdk.mapfwk.core.Session;
import com.informatica.powercenter.sdk.mapfwk.core.Target;
import com.informatica.powercenter.sdk.mapfwk.core.Workflow;
import com.informatica.powercenter.sdk.mapfwk.repository.PmrepRepositoryConnectionManager;
import com.informatica.powercenter.sdk.mapfwk.repository.RepoPropsConstants;
import com.informatica.powercenter.sdk.mapfwk.repository.Repository;
import org.willian.owb2infa.helper.HelperBase;

/**
 *
 *
 */
public abstract class Base extends HelperBase {

	// ///////////////////////////////////////////////////////////////////////////////////
	// Instance variables
	// ///////////////////////////////////////////////////////////////////////////////////

	protected Repository rep;
	protected Folder folder;
	protected Session session;
	protected Workflow workflow;
	protected String mapFileName;
	protected Mapping mapping;
	protected int runMode = 0;

	protected String infaDir;
	protected String folderName;

	private Logger logger = LogManager.getLogger(Base.class);

	/**
	 * Common execute method
	 */
	public void execute() throws Exception {
		init();
		createMappings();
		createSession();
		createWorkflow();
		generateOutput();

	}

	/**
	 * Initialize the method
	 */
	protected void init() {

		createRepository();

		try {
			intializeLocalProps();
			rep.setRepositoryConnectionManager(new PmrepRepositoryConnectionManager());
			logger.debug("Init finished.");
		} catch (IOException ioExcp) {
			logger.error(ioExcp.getMessage());
			logger.error("Error reading pcconfig.properties file.");
			logger.error("pcconfig.properties file is present in \\javamappingsdk\\samples directory");
			System.exit(0);
		}

		createFolder();

		logger.debug("Start to create the source");
		createSources();

		logger.debug("Start to create the targets");
		createTargets();

	}

	/**
	 * Create a repository
	 */
	protected void createRepository() {
		rep = new Repository("MetadataMigratorRepo", "MetadataMigratorRepository",
				"This repository contains the migrated metadata from OWB");
	}

	/**
	 * Creates a folder
	 */
	protected void createFolder() {
		folderName = rep.getRepoConnectionInfo().getTargetFolderName();
		folder = new Folder(folderName, "test_migrator",
				"This is a folder containing mappinged generated by java mapping program");
		rep.addFolder(folder);
	}

	/**
	 * Create sources
	 */
	protected abstract void createSources(); // override in base class to create
												// appropriate sources

	/**
	 * Create targets
	 */
	protected abstract void createTargets(); // override in base class to create
												// appropriate targets

	/**
	 * Creates a mapping It needs to be overriddden for the sample
	 * 
	 * @return Mapping
	 */
	protected abstract void createMappings() throws Exception; // override in
																// base class

	/**
	 * Create session
	 */
	protected abstract void createSession() throws Exception;

	/**
	 * Create workflow
	 */
	protected abstract void createWorkflow() throws Exception;

	protected ConnectionInfo getRelationalConnInfo(SourceTargetType dbType, String dbName) {
		ConnectionInfo connInfo = null;
		connInfo = new ConnectionInfo(dbType);
		connInfo.getConnProps().setProperty(ConnectionPropsConstants.DBNAME, dbName);
		return connInfo;
	}

	/**
	 * Method to create relational target
	 */
	protected Target createRelationalTarget(SourceTargetType DBType, String name) {
		Target target = new Target(name, name, name, name, new ConnectionInfo(DBType));
		return target;
	}

	/**
	 * This method creates the target for the mapping
	 * 
	 * @return
	 */
	public Target createFlatFileTarget(String name) {
		Target tgt = new Target(name, name, "", name, new ConnectionInfo(SourceTargetType.Flat_File));
		tgt.getConnInfo().getConnProps().setProperty(ConnectionPropsConstants.FLATFILE_CODEPAGE, "MS1252");
		tgt.getConnInfo().getConnProps().setProperty(ConnectionPropsConstants.OUTPUT_FILENAME, name + ".out");
		return tgt;
	}

	/**
	 * This method creates the target for relational database
	 * 
	 * @param name
	 * @param relationalType
	 * @return
	 */
	public Target createRelationalTarget(String name, SourceTargetType relationalType) {
		Target tgt = new Target(name, name, "", name, new ConnectionInfo(relationalType));
		return tgt;
	}

	/**
	 * This method generates the output xml
	 * 
	 * @throws Exception
	 *             exception
	 */
	public void generateOutput() {
		MapFwkOutputContext outputContext = new MapFwkOutputContext(MapFwkOutputContext.OUTPUT_FORMAT_XML,
				MapFwkOutputContext.OUTPUT_TARGET_FILE, mapFileName);
		// MapFwkOutputContext outputContext = new MapFwkOutputContext(
		// MapFwkOutputContext.OUTPUT_FORMAT_XML,
		// MapFwkOutputContext.OUTPUT_TARGET_STREAM, System.out);

		try {

			if (runMode == 1) {
				logger.debug("Import the Informatica XML into repository");
				rep.save(outputContext, true);
			} else {
				logger.debug("Only generate the Informatica XML file");

				rep.save(outputContext, false);
			}
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		logger.debug("Mapping generated in " + mapFileName);

		logger.debug("To manually fix the informatica xml");
		manualFixInfaXML(mapFileName);

	}

	protected void setMapFileName(Mapping mapping) {
		StringBuffer buff = new StringBuffer();
		buff.append(infaDir);
		buff.append(java.io.File.separatorChar);
		buff.append(mapping.getName());
		buff.append("_temp.xml");
		File file = new File(buff.toString());

		mapFileName = file.getAbsolutePath();

		logger.trace("The export informatica mapFileName is " + mapFileName);
	}

	protected ConnectionInfo getFlatFileConnectionInfo() {

		ConnectionInfo infoProps = new ConnectionInfo(SourceTargetType.Flat_File);
		infoProps.getConnProps().setProperty(ConnectionPropsConstants.FLATFILE_SKIPROWS, "1");
		infoProps.getConnProps().setProperty(ConnectionPropsConstants.FLATFILE_DELIMITERS, ",");
		infoProps.getConnProps().setProperty(ConnectionPropsConstants.DATETIME_FORMAT, "A  21 yyyy/mm/dd hh24:mi:ss");
		infoProps.getConnProps().setProperty(ConnectionPropsConstants.FLATFILE_QUOTE_CHARACTER, "DOUBLE");

		return infoProps;

	}

	protected ConnectionInfo getRelationalConnectionInfo(SourceTargetType dbType) {
		ConnectionInfo infoProps = new ConnectionInfo(dbType);
		return infoProps;
	}

	/**
	 * Method to get relational connection info object
	 */
	protected ConnectionInfo getRelationalConnectionInfo(SourceTargetType dbType, String dbName) {
		ConnectionInfo connInfo = new ConnectionInfo(dbType);
		connInfo.getConnProps().setProperty(ConnectionPropsConstants.DBNAME, dbName);
		return connInfo;
	}

	protected void intializeLocalProps() throws IOException {

		CONF_FILE = "pcconfig.properties";
		Properties properties = null;
		try {
			properties = getLocalProps(CONF_FILE);
		} catch (IOException ioExcp) {
			logger.error(ioExcp.getMessage());
			logger.error("Error reading " + CONF_FILE + " file.");
			logger.error(CONF_FILE + " file not found. Add Directory containing this file to ClassPath");
			System.exit(0);
		}
		if (properties != null && properties.size() > 0) {
			rep.getRepoConnectionInfo().setPcClientInstallPath(
					properties.getProperty(RepoPropsConstants.PC_CLIENT_INSTALL_PATH));
			rep.getRepoConnectionInfo().setTargetFolderName(
					properties.getProperty(RepoPropsConstants.TARGET_FOLDER_NAME));
			rep.getRepoConnectionInfo().setTargetRepoName(properties.getProperty(RepoPropsConstants.TARGET_REPO_NAME));
			rep.getRepoConnectionInfo().setRepoServerHost(properties.getProperty(RepoPropsConstants.REPO_SERVER_HOST));
			rep.getRepoConnectionInfo().setAdminPassword(properties.getProperty(RepoPropsConstants.ADMIN_PASSWORD));
			rep.getRepoConnectionInfo().setAdminUsername(properties.getProperty(RepoPropsConstants.ADMIN_USERNAME));
			rep.getRepoConnectionInfo().setRepoServerPort(properties.getProperty(RepoPropsConstants.REPO_SERVER_PORT));
			rep.getRepoConnectionInfo().setServerPort(properties.getProperty(RepoPropsConstants.SERVER_PORT));
			rep.getRepoConnectionInfo().setDatabaseType(properties.getProperty(RepoPropsConstants.DATABASETYPE));

			if (properties.getProperty(RepoPropsConstants.PMREP_CACHE_FOLDER) != null)
				rep.getRepoConnectionInfo().setPmrepCacheFolder(
						properties.getProperty(RepoPropsConstants.PMREP_CACHE_FOLDER));
		} else {
			throw new IOException(
					"pcconfig.properties file not found.Add Directory containing pcconfig.properties to ClassPath");
		}

		logger.debug("Local property has been read for initialize Informatica repository");
	}

	public boolean validateRunMode(int mode) {

		if (mode == 1 || mode == 0) {
			runMode = mode;
			return true;

		} else {
			return false;
		}
	}

	public String getInfaDir() {
		return infaDir;
	}

	public void setInfaDir(String infaDir) {
		this.infaDir = infaDir;
	}

	public void manualFixInfaXML(String filename) {

		File orginalFile = new File(filename);
		FileReader fr = null;
		LineNumberReader lr = null;
		FileWriter writer = null;
		File tempFile = new File(infaDir + File.separator + mapping.getName() + ".xml");

		try {
			//			tempFile = File.createTempFile("InfaSDKMigrator", ".temp");

			logger.trace(("Output file : " + tempFile.getAbsolutePath()));
			writer = new FileWriter(tempFile);

			fr = new FileReader(orginalFile);
			lr = new LineNumberReader(fr);

			for (String line = lr.readLine(); line != null; line = lr.readLine()) {

				if (line.indexOf("<SHORTCUT") != -1) {

					if (line.indexOf("TGT_") != -1) {
						line = line.replace("TGT_", "");

						logger.trace("Replace TGT_ in xml file");
					}

					if (line.indexOf("Ins_") != -1) {
						line = "<!-- " + line + " -->";

						logger.trace("Replace Ins_ in xml file");
					}

					if (line.indexOf("Upd_") != -1) {
						line = "<!-- " + line + " -->";

						logger.trace("Replace Upd_ in xml file");
					}

				}
				writer.write(line + "\n");

			}

			//			orginalFile.delete();
			//			File tempFile2 = new File(filename + "_fix" + ".temp");
			//			boolean renameSuccess = tempFile.renameTo(tempFile2);
			//
			//			if (!renameSuccess) {
			//				logger.error("Faild to rename the manual fixed file");
			//			}
			//			logger.trace(("After renaming, Temp file : " + tempFile.getAbsolutePath()));

			fr.close();
			lr.close();
			writer.close();

			boolean deleteSuccess = orginalFile.delete();

			if (deleteSuccess) {
				logger.trace("Successfully delete the original file");
			} else {
				logger.trace("Failed to delete the original file");
			}
		} catch (IOException e) {
			logger.error("Failed to manual fix infa xml file");
			logger.error(HelperBase.getStackTrace(e));
		}
	}

}
